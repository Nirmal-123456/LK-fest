// Arduino Simon-style LED Memory Game
// Pins & settings - change if needed
const uint8_t LED_PINS[4]  = {2, 3, 4, 5};
const uint8_t BTN_PINS[4]  = {6, 7, 8, 9};
const uint8_t BUZZER_PIN  = 10;
const uint8_t START_PIN   = 11;

#include <EEPROM.h>

const uint8_t MAX_LEVEL = 32;    // max pattern length stored
uint8_t pattern[MAX_LEVEL];
uint8_t level = 1;              // current target sequence length
uint16_t highScoreAddr = 0;     // EEPROM address to store high score

// Timings (ms)
unsigned long lightOnTime    = 500;
unsigned long lightOffTime   = 200;
unsigned long betweenRounds  = 800;
unsigned long inputTimeout   = 5000; // ms to wait for each input

// debounce
const unsigned long DEBOUNCE_MS = 40;

void setup() {
  Serial.begin(115200);
  // LEDs
  for (uint8_t i=0;i<4;i++) pinMode(LED_PINS[i], OUTPUT);
  // Buttons (use internal pullup)
  for (uint8_t i=0;i<4;i++) pinMode(BTN_PINS[i], INPUT_PULLUP);
  // Buzzer and start pin
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(START_PIN, INPUT_PULLUP);

  // Seed RNG with floating analog pin
  randomSeed(analogRead(A0));

  // Generate initial random pattern
  for (uint8_t i=0;i<MAX_LEVEL;i++) pattern[i] = random(0,4);

  // Show startup message
  beepStart();
  delay(200);
  flashAll(2, 120);
  Serial.println("Simon memory game ready. Press START (pin 11) or reset to begin.");
}

void loop() {
  // Wait for start press
  waitForStart();

  level = 1;
  // Load existing random pattern -- you can re-generate if you want new each game
  // pattern already seeded in setup

  uint16_t savedHigh = readHighScore();
  Serial.print("High score: "); Serial.println(savedHigh);

  while (true) {
    Serial.print("Play level: "); Serial.println(level);
    playSequence(level);
    bool ok = getPlayerInput(level);
    if (!ok) {
      // game over
      gameOver();
      uint16_t prevHigh = readHighScore();
      if (level-1 > prevHigh) {
        writeHighScore(level-1);
        Serial.print("New High Score: ");
        Serial.println(level-1);
        flashAll(6, 80);
        for (int i=0;i<2;i++) beep(100, 100);
      }
      break;
    } else {
      // level passed
      successTone();
      level++;
      if (level > MAX_LEVEL) {
        // player won full game
        for (int i=0;i<6;i++) { flashAll(1,80); beep(150,80); delay(50); }
        writeHighScore(MAX_LEVEL);
        break;
      }
      // slightly speed up
      if (lightOnTime > 150) lightOnTime -= 15;
      if (lightOffTime > 80) lightOffTime -= 8;
      delay(betweenRounds/2);
    }
  }

  // after game ends, wait a bit then allow restart
  Serial.println("Game finished. Press START to play again.");
  delay(1000);
}

void waitForStart() {
  // Wait until START pin pressed (grounded)
  while (digitalRead(START_PIN) == HIGH) {
    // Also allow pressing any button to start (optional)
    for (uint8_t b=0;b<4;b++){
      if (buttonPressed(b)) return;
    }
    delay(50);
  }
  // debounce wait release
  delay(150);
}

void playSequence(uint8_t len) {
  for (uint8_t i=0;i<len;i++) {
    uint8_t p = pattern[i];
    lightOn(p);
    delay(lightOnTime);
    lightOff(p);
    delay(lightOffTime);
  }
}

bool getPlayerInput(uint8_t len) {
  unsigned long startTime;
  for (uint8_t i=0;i<len;i++) {
    startTime = millis();
    int choice = waitForButtonPress(inputTimeout);
    if (choice < 0) {
      Serial.println("Input timeout!");
      return false;
    }
    // show pressed LED briefly and play tone
    lightOn(choice);
    beepFor(choice);
    delay(180);
    lightOff(choice);

    if (choice != pattern[i]) {
      Serial.print("Wrong! expected ");
      Serial.print(pattern[i]);
      Serial.print(" got ");
      Serial.println(choice);
      return false;
    }
  }
  return true;
}

// Waits for any of the 4 buttons to be pressed. Returns button index 0..3 or -1 on timeout
int waitForButtonPress(unsigned long timeout_ms) {
  unsigned long start = millis();
  while (millis() - start < timeout_ms) {
    for (uint8_t b=0;b<4;b++) {
      if (buttonPressed(b)) {
        // simple debounce
        delay(DEBOUNCE_MS);
        // wait until release
        while (buttonPressed(b)) delay(10);
        return b;
      }
    }
    delay(6);
  }
  return -1;
}

// read button with inverted logic (INPUT_PULLUP)
bool buttonPressed(uint8_t idx) {
  return digitalRead(BTN_PINS[idx]) == LOW;
}

void lightOn(uint8_t idx) {
  digitalWrite(LED_PINS[idx], HIGH);
}
void lightOff(uint8_t idx) {
  digitalWrite(LED_PINS[idx], LOW);
}

void flashAll(uint8_t times, uint16_t msDelay) {
  for (uint8_t t=0;t<times;t++) {
    for (uint8_t i=0;i<4;i++) digitalWrite(LED_PINS[i], HIGH);
    delay(msDelay);
    for (uint8_t i=0;i<4;i++) digitalWrite(LED_PINS[i], LOW);
    delay(msDelay);
  }
}

void beep(unsigned int freq, unsigned int durationMs) {
  if (freq == 0) { noTone(BUZZER_PIN); delay(durationMs); return; }
  tone(BUZZER_PIN, freq, durationMs);
  delay(durationMs + 10);
  noTone(BUZZER_PIN);
}

void beepFor(uint8_t idx) {
  // map idx to tone
  const unsigned int tones[4] = {440, 554, 659, 784}; // A4, C#5, E5, G5
  beep(tones[idx], 160);
}

void beepStart() {
  beep(392, 80);
  delay(40);
  beep(523, 80);
}

void successTone() {
  beep(880, 120);
  delay(30);
  beep(1100, 80);
}

void gameOver() {
  // dramatic failure tone and blink
  for (int i=0;i<3;i++) {
    for (uint8_t j=0;j<4;j++) digitalWrite(LED_PINS[j], HIGH);
    beep(220, 250);
    for (uint8_t j=0;j<4;j++) digitalWrite(LED_PINS[j], LOW);
    delay(150);
  }
}

// EEPROM helpers
uint16_t readHighScore() {
  uint16_t v = 0;
  v = EEPROM.read(highScoreAddr);
  v |= (EEPROM.read(highScoreAddr+1) << 8);
  return v;
}
void writeHighScore(uint16_t val) {
  EEPROM.write(highScoreAddr, val & 0xFF);
  EEPROM.write(highScoreAddr+1, (val >> 8) & 0xFF);
  EEPROM.commit(); // some boards ignore, safe to call
}
